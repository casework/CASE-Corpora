#!/usr/bin/env python3

# Portions of this file contributed by NIST are governed by the
# following statement:
#
# This software was developed at the National Institute of Standards
# and Technology by employees of the Federal Government in the course
# of their official duties. Pursuant to Title 17 Section 105 of the
# United States Code, this software is not subject to copyright
# protection within the United States. NIST assumes no responsibility
# whatsoever for its use by other parties, and makes no guarantees,
# expressed or implied, about its quality, reliability, or any other
# characteristic.
#
# We would appreciate acknowledgement if the software is used.

"""
This single-purpose script takes as input a manifest of mobile phone applications and instantiates graph nodes.

NOTE: This script makes some operational assumptions that may make it unfit for general consumption.
* An Application node generated by this script is considered to be "inherent" to the operating system on which it is installed.  This disregards the separate need to be able to represent an application in a "pre-installation" state, such as in an application marketplace.
* No ability is present for this script to distinguish between applications that are installed at a version X, uninstalled, and then installed again at the same version X.  This representation requires either considering Applications to consider their generation event to be part of their identity, or for Applications to be represented as what would be part of a "temporary situation" in the (gentle) Unified Formal Ontology (gUFO).  For the purposes of modeling the Digital Corpora mobile phones in a static post-mortem forensic analysis where reinstallation did not occur, this question is left for future consideration.

The expected format of the input is four columns, the last two optional:
1. App name
2. App version
3. App install day
4. App install time

This script outputs a Turtle graph.  The generated graph should be manually inserted into the CASE-Corpora supplemental data.
"""

import sys
from typing import Optional
from uuid import NAMESPACE_URL, uuid5

from case_utils.namespace import NS_RDF, NS_UCO_CORE, NS_UCO_OBSERVABLE, NS_XSD
from rdflib import PROV, TIME, Graph, Literal, Namespace, URIRef

NS_KB = Namespace("http://example.org/kb/")
NS_PROV = PROV
NS_TIME = TIME


def main() -> None:
    graph = Graph()

    graph.bind("kb", NS_KB)
    graph.bind("prov", NS_PROV)
    graph.bind("rdf", NS_RDF)
    graph.bind("time", NS_TIME)
    graph.bind("uco-core", NS_UCO_CORE)
    graph.bind("uco-observable", NS_UCO_OBSERVABLE)
    graph.bind("xsd", NS_XSD)

    n_operating_system = NS_KB["operating-system-f40a533d-9b1e-49ad-ae21-a4c69a4c49f4"]
    operating_system_iri = str(n_operating_system)

    with open("apps.tsv", "r") as in_fh:
        for line in in_fh:
            cleaned_line = line.strip()
            if cleaned_line == "":
                continue
            line_parts = line.split("\t")
            app_name = line_parts[0].strip()
            app_version = line_parts[1].strip()
            app_install_day: Optional[str] = None
            app_install_time: Optional[str] = None
            if len(line_parts) > 2:
                app_install_day = line_parts[2].strip()
                if len(line_parts) > 3:
                    app_install_time = line_parts[3].strip()

            # Define Application's UUID5 using inherence to the operating system.
            # Note that this strategy does not necessarily account for an application being installed, uninstalled, and reinstalled later.  UCO does not currently define whether that coincidence of application name-version pairs should imply the same application graph-node should be used.
            application_uuid5_seed: str = "%s/application/%s/%s" % (
                operating_system_iri,
                app_name,
                app_version,
            )
            application_uuid: str = str(uuid5(NAMESPACE_URL, application_uuid5_seed))
            n_application: URIRef = NS_KB["application-" + application_uuid]

            # Define ApplicationFacet's UUID5 using inherence to the Application.
            application_facet_uuid5_seed: str = "%s/%s" % (
                str(n_application),
                str(NS_UCO_OBSERVABLE.ApplicationFacet),
            )
            application_facet_uuid: str = str(
                uuid5(NAMESPACE_URL, application_facet_uuid5_seed)
            )
            n_application_facet: URIRef = NS_KB[
                "application-facet-" + application_facet_uuid
            ]
            graph.add((n_application, NS_RDF.type, NS_UCO_OBSERVABLE.Application))
            graph.add((n_application, NS_RDF.type, NS_PROV.Entity))
            graph.add((n_application, NS_UCO_CORE.name, Literal(app_name)))
            graph.add(
                (
                    n_application,
                    NS_UCO_CORE.description,
                    Literal("Application: %s" % app_name),
                )
            )
            graph.add((n_application, NS_UCO_CORE.hasFacet, n_application_facet))
            graph.add(
                (n_application_facet, NS_RDF.type, NS_UCO_OBSERVABLE.ApplicationFacet)
            )
            graph.add(
                (n_application_facet, NS_UCO_OBSERVABLE.version, Literal(app_version))
            )
            graph.add(
                (
                    n_application_facet,
                    NS_UCO_OBSERVABLE.operatingSystem,
                    n_operating_system,
                )
            )

            if app_install_day is not None:
                # Define Generation's UUID5 using inherence to the Application.
                generation_uuid5_seed: str = "%s/%s" % (
                    str(n_application),
                    str(NS_PROV.Generation),
                )
                generation_uuid: str = str(uuid5(NAMESPACE_URL, generation_uuid5_seed))
                n_generation: URIRef = NS_KB["generation-" + generation_uuid]
                graph.add((n_generation, NS_RDF.type, NS_PROV.Generation))
                graph.add((n_generation, NS_RDF.type, NS_TIME.Instant))
                graph.add((n_application, NS_PROV.qualifiedGeneration, n_generation))
                if app_install_time is None:
                    graph.add(
                        (
                            n_generation,
                            NS_TIME.inXSDDate,
                            Literal(app_install_day, datatype=NS_XSD.date),
                        )
                    )
                else:
                    graph.add(
                        (
                            n_generation,
                            NS_TIME.inXSDDateTimeStamp,
                            Literal(
                                app_install_day + "T" + app_install_time + "-05:00",
                                datatype=NS_XSD.dateTimeStamp,
                            ),
                        )
                    )

    graph.serialize(sys.argv[1], format="longturtle")


if __name__ == "__main__":
    main()
